<!DOCTYPE html>
<html lang="en">
<head>
        <title>SetupFeatures (during.io_uring.SetupFeatures)</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		</nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		<h1>SetupFeatures</h1><div class="breadcrumbs"><a class="breadcrumb" href="during.html">during</a> <a class="breadcrumb" href="during.io_uring.html">io_uring</a> </div><div><div class="documentation-comment synopsis"><div><p><tt class="inline-code">io_uring_params-&gt;features</tt> flags</p></div></div></div><div class="annotated-prototype"></div><h2 id="values"><a class="header-anchor" href="#values">Values</a></h2><table class="enum-members"><tr><th>Value</th><th>Meaning</th></tr><tr class="enum-member" id="NONE"><td><a class="enum-member-name" href="#NONE">NONE</a><span class="enum-member-value"><tt class="highlighted"><span class="num">0</span></tt></span><div class="enum-attributes"></div></td><td><div></div></td></tr><tr class="enum-member" id="SINGLE_MMAP"><td><a class="enum-member-name" href="#SINGLE_MMAP">SINGLE_MMAP</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">0</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_FEAT_SINGLE_MMAP</tt> (from Linux 5.4)</p><p>Indicates that we can use single mmap feature to map both sq and cq rings and so to avoid the
second mmap.</p></div></td></tr><tr class="enum-member" id="NODROP"><td><a class="enum-member-name" href="#NODROP">NODROP</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">1</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_FEAT_NODROP</tt> (from Linux 5.5)</p><p>Currently we drop completion events, if the CQ ring is full. That's fine
for requests with bounded completion times, but it may make it harder or
impossible to use io_uring with networked IO where request completion
times are generally unbounded. Or with POLL, for example, which is also
unbounded.</p><p>After this patch, we never overflow the ring, we simply store requests
in a backlog for later flushing. This flushing is done automatically by
the kernel. To prevent the backlog from growing indefinitely, if the
backlog is non-empty, we apply back pressure on IO submissions. Any
attempt to submit new IO with a non-empty backlog will get an -EBUSY
return from the kernel. This is a signal to the application that it has
backlogged CQ events, and that it must reap those before being allowed
to submit more IO.</p><p>Note that if we do return -EBUSY, we will have filled whatever
backlogged events into the CQ ring first, if there's room. This means
the application can safely reap events WITHOUT entering the kernel and
waiting for them, they are already available in the CQ ring.</p></div></td></tr><tr class="enum-member" id="SUBMIT_STABLE"><td><a class="enum-member-name" href="#SUBMIT_STABLE">SUBMIT_STABLE</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">2</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_FEAT_SUBMIT_STABLE</tt> (from Linux 5.5)</p><p>If this flag is set, applications can be certain that any data for async offload has been
consumed when the kernel has consumed the SQE.</p></div></td></tr><tr class="enum-member" id="RW_CUR_POS"><td><a class="enum-member-name" href="#RW_CUR_POS">RW_CUR_POS</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">3</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_FEAT_RW_CUR_POS</tt> (from Linux 5.6)</p><p>If this flag is set, applications can know if setting <tt class="inline-code">-1</tt> as file offsets (meaning to work
with current file position) is supported.</p></div></td></tr><tr class="enum-member" id="CUR_PERSONALITY"><td><a class="enum-member-name" href="#CUR_PERSONALITY">CUR_PERSONALITY</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">4</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_FEAT_CUR_PERSONALITY</tt> (from Linux 5.6)
We currently setup the io_wq with a static set of mm and creds. Even for a single-use io-wq
per io_uring, this is suboptimal as we have may have multiple enters of the ring. For
sharing the io-wq backend, it doesn't work at all.</p><p>Switch to passing in the creds and mm when the work item is setup. This means that async
work is no longer deferred to the io_uring mm and creds, it is done with the current mm and
creds.</p><p>Flag this behavior with IORING_FEAT_CUR_PERSONALITY, so applications know they can rely on
the current personality (mm and creds) being the same for direct issue and async issue.</p></div></td></tr><tr class="enum-member" id="FAST_POLL"><td><a class="enum-member-name" href="#FAST_POLL">FAST_POLL</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">5</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_FEAT_FAST_POLL</tt> (from Linux 5.7)
Currently io_uring tries any request in a non-blocking manner, if it can, and then retries
from a worker thread if we get -EAGAIN. Now that we have a new and fancy poll based retry
backend, use that to retry requests if the file supports it.</p><p>This means that, for example, an IORING_OP_RECVMSG on a socket no longer requires an async
thread to complete the IO. If we get -EAGAIN reading from the socket in a non-blocking
manner, we arm a poll handler for notification on when the socket becomes readable. When it
does, the pending read is executed directly by the task again, through the io_uring task
work handlers. Not only is this faster and more efficient, it also means we're not
generating potentially tons of async threads that just sit and block, waiting for the IO to
complete.</p><p>The feature is marked with IORING_FEAT_FAST_POLL, meaning that async pollable IO is fast,
and that poll&lt;link&gt;other_op is fast as well.</p></div></td></tr><tr class="enum-member" id="POLL_32BITS"><td><a class="enum-member-name" href="#POLL_32BITS">POLL_32BITS</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">6</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_FEAT_POLL_32BITS</tt> (from Linux 5.9)
Poll events should be 32-bits to cover EPOLLEXCLUSIVE.
Explicit word-swap the poll32_events for big endian to make sure the ABI is not changed.  We
call this feature IORING_FEAT_POLL_32BITS, applications who want to use EPOLLEXCLUSIVE should
check the feature bit first.</p></div></td></tr></table><div><h2 id="meta"><a class="header-anchor" href="#meta">Meta</a></h2><div class="documentation-comment source-section other-section"><h3 id="source"><a class="header-anchor" href="#source">Source</a></h3><div><p><a href="source/during.io_uring.d.html#L670">See Implementation</a><br /></p></div></div></div></div>
		<div id="page-nav"><a class="parent" href="during.html">during</a> <a class="parent" href="during.io_uring.html">io_uring</a> 
		<span class="type-separator">enums</span><ul><li><a class="enum" href="during.io_uring.AcceptFlags.html">AcceptFlags</a></li><li><a class="enum" href="during.io_uring.CQEFlags.html">CQEFlags</a></li><li><a class="enum" href="during.io_uring.CQRingFlags.html">CQRingFlags</a></li><li><a class="enum" href="during.io_uring.EnterFlags.html">EnterFlags</a></li><li><a class="enum" href="during.io_uring.MsgFlags.html">MsgFlags</a></li><li><a class="enum" href="during.io_uring.Operation.html">Operation</a></li><li><a class="enum" href="during.io_uring.PollEvents.html">PollEvents</a></li><li><a class="enum" href="during.io_uring.RegisterOpCode.html">RegisterOpCode</a></li><li><a class="enum current" href="during.io_uring.SetupFeatures.html">SetupFeatures</a></li><li><a class="enum" href="during.io_uring.SetupFlags.html">SetupFlags</a></li><li><a class="enum" href="during.io_uring.SubmissionEntryFlags.html">SubmissionEntryFlags</a></li><li><a class="enum" href="during.io_uring.SyncFileRangeFlags.html">SyncFileRangeFlags</a></li><li><a class="enum" href="during.io_uring.TimeoutFlags.html">TimeoutFlags</a></li></ul><span class="type-separator">functions</span><ul><li><a class="function" href="during.io_uring.io_uring_enter.html">io_uring_enter</a></li><li><a class="function" href="during.io_uring.io_uring_register.html">io_uring_register</a></li><li><a class="function" href="during.io_uring.io_uring_setup.html">io_uring_setup</a></li></ul><span class="type-separator">manifest constants</span><ul><li><a class="manifest-constant" href="during.io_uring.IO_URING_OP_SUPPORTED.html">IO_URING_OP_SUPPORTED</a></li><li><a class="manifest-constant" href="during.io_uring.SPLICE_F_FD_IN_FIXED.html">SPLICE_F_FD_IN_FIXED</a></li></ul><span class="type-separator">structs</span><ul><li><a class="struct" href="during.io_uring.CompletionEntry.html">CompletionEntry</a></li><li><a class="struct" href="during.io_uring.CompletionQueueRingOffsets.html">CompletionQueueRingOffsets</a></li><li><a class="struct" href="during.io_uring.KernelTimespec.html">KernelTimespec</a></li><li><a class="struct" href="during.io_uring.SetupParameters.html">SetupParameters</a></li><li><a class="struct" href="during.io_uring.SubmissionEntry.html">SubmissionEntry</a></li><li><a class="struct" href="during.io_uring.SubmissionQueueRingOffsets.html">SubmissionQueueRingOffsets</a></li></ul></div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>
</body>
</html>