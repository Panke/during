<!DOCTYPE html>
<html>
<head>
        <title>RegisterOpCode (during.io_uring.RegisterOpCode)</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		</nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		<h1>RegisterOpCode</h1><div class="breadcrumbs"><a class="breadcrumb" href="during.html">during</a><a class="breadcrumb" href="during.io_uring.html">io_uring</a></div><div><div class="documentation-comment synopsis"><div><p>io_uring_register(2) opcodes and arguments</p></div></div></div><div class="annotated-prototype"></div><h2 id="values"><a class="header-anchor" href="#values">Values</a></h2><table class="enum-members"><tr><th>Value</th><th>Meaning</th></tr><tr class="enum-member" id="REGISTER_BUFFERS"><td><a class="enum-member-name" href="#REGISTER_BUFFERS">REGISTER_BUFFERS</a><span class="enum-member-value"><tt class="highlighted"><span class="num">0</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">arg</tt> points to a struct iovec array of nr_args entries.  The buffers associated with the
iovecs will be locked in memory and charged against the user's RLIMIT_MEMLOCK resource limit.
See getrlimit(2) for more  informa&#8208; tion.   Additionally,  there  is a size limit of 1GiB per
buffer.  Currently, the buffers must be anonymous, non-file-backed memory, such as that
returned by malloc(3) or mmap(2) with the MAP_ANONYMOUS flag set.  It is expected that this
limitation will be lifted in the future. Huge pages are supported as well. Note that the
entire huge page will be pinned in the kernel, even if only a portion of it is used.</p><p>After a successful call, the supplied buffers are mapped into the kernel and eligible for
I/O.  To make use of them, the application must specify the IORING_OP_READ_FIXED or
IORING_OP_WRITE_FIXED opcodes in the submis&#8208; sion  queue  entry (see the struct io_uring_sqe
definition in io_uring_enter(2)), and set the buf_index field to the desired buffer index.
The memory range described by the submission queue entry's addr and len fields must fall
within the indexed buffer.</p><p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as
long as the range is within the originally mapped region.</p><p>An application can increase or decrease the size or number of registered buffers by first
unregistering the existing buffers, and then issuing a new call to io_uring_register() with
the new buffers.</p><p>An application need not unregister buffers explicitly before shutting down the io_uring
instance.</p><p><tt class="inline-code">IORING_REGISTER_BUFFERS</tt></p></div></td></tr><tr class="enum-member" id="UNREGISTER_BUFFERS"><td><a class="enum-member-name" href="#UNREGISTER_BUFFERS">UNREGISTER_BUFFERS</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1</span></tt></span><div class="enum-attributes"></div></td><td><div><p>This operation takes no argument, and <tt class="inline-code">arg</tt> must be passed as NULL. All previously registered
buffers associated with the io_uring instance will be released.</p><p><tt class="inline-code">IORING_UNREGISTER_BUFFERS</tt></p></div></td></tr><tr class="enum-member" id="REGISTER_FILES"><td><a class="enum-member-name" href="#REGISTER_FILES">REGISTER_FILES</a><span class="enum-member-value"><tt class="highlighted"><span class="num">2</span></tt></span><div class="enum-attributes"></div></td><td><div><p>Register files for I/O. <tt class="inline-code">arg</tt> contains a pointer to an array of <tt class="inline-code">nr_args</tt> file descriptors
(signed 32 bit integers).</p><p>To make use of the registered files, the IOSQE_FIXED_FILE flag must be set in the flags
member of the struct io_uring_sqe, and the fd member is set to the index of the file in the
file descriptor array.</p><p>Files are automatically unregistered when the io_uring instance is torn down. An application
need only unregister if it wishes to register a new set of fds.</p><p><tt class="inline-code">IORING_REGISTER_FILES</tt></p></div></td></tr><tr class="enum-member" id="UNREGISTER_FILES"><td><a class="enum-member-name" href="#UNREGISTER_FILES">UNREGISTER_FILES</a><span class="enum-member-value"><tt class="highlighted"><span class="num">3</span></tt></span><div class="enum-attributes"></div></td><td><div><p>This operation requires no argument, and <tt class="inline-code">arg</tt> must be passed as NULL.  All previously
registered files associated with the io_uring instance will be unregistered.</p><p><tt class="inline-code">IORING_UNREGISTER_FILES</tt></p></div></td></tr><tr class="enum-member" id="REGISTER_EVENTFD"><td><a class="enum-member-name" href="#REGISTER_EVENTFD">REGISTER_EVENTFD</a><span class="enum-member-value"><tt class="highlighted"><span class="num">4</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_REGISTER_EVENTFD</tt></p><p>Registers eventfd that would be used to notify about completions on io_uring itself.</p><p>Note: available from Linux 5.2</p></div></td></tr><tr class="enum-member" id="UNREGISTER_EVENTFD"><td><a class="enum-member-name" href="#UNREGISTER_EVENTFD">UNREGISTER_EVENTFD</a><span class="enum-member-value"><tt class="highlighted"><span class="num">5</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_UNREGISTER_EVENTFD</tt></p><p>Unregisters previously registered eventfd.</p><p>Note: available from Linux 5.2</p></div></td></tr><tr class="enum-member" id="REGISTER_FILES_UPDATE"><td><a class="enum-member-name" href="#REGISTER_FILES_UPDATE">REGISTER_FILES_UPDATE</a><span class="enum-member-value"><tt class="highlighted"><span class="num">6</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_REGISTER_FILES_UPDATE</tt> (from Linux 5.5)</p></div></td></tr><tr class="enum-member" id="REGISTER_EVENTFD_ASYNC"><td><a class="enum-member-name" href="#REGISTER_EVENTFD_ASYNC">REGISTER_EVENTFD_ASYNC</a><span class="enum-member-value"><tt class="highlighted"><span class="num">7</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_REGISTER_EVENTFD_ASYNC</tt> (from Linux 5.6)</p><p>If an application is using eventfd notifications with poll to know when new SQEs can be
issued, it's expecting the following read/writes to complete inline. And with that, it knows
that there are events available, and don't want spurious wakeups on the eventfd for those
requests.</p><p>This adds IORING_REGISTER_EVENTFD_ASYNC, which works just like IORING_REGISTER_EVENTFD,
except it only triggers notifications for events that happen from async completions (IRQ, or
io-wq worker completions). Any completions inline from the submission itself will not
trigger notifications.</p></div></td></tr><tr class="enum-member" id="REGISTER_PROBE"><td><a class="enum-member-name" href="#REGISTER_PROBE">REGISTER_PROBE</a><span class="enum-member-value"><tt class="highlighted"><span class="num">8</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_REGISTER_PROBE</tt> (from Linux 5.6)</p><p>The application currently has no way of knowing if a given opcode is supported or not
without having to try and issue one and see if we get -EINVAL or not. And even this approach
is fraught with peril, as maybe we're getting -EINVAL due to some fields being missing, or
maybe it's just not that easy to issue that particular command without doing some other leg
work in terms of setup first.</p><p>This adds IORING_REGISTER_PROBE, which fills in a structure with info on what it supported
or not. This will work even with sparse opcode fields, which may happen in the future or
even today if someone backports specific features to older kernels.</p></div></td></tr><tr class="enum-member" id="REGISTER_PERSONALITY"><td><a class="enum-member-name" href="#REGISTER_PERSONALITY">REGISTER_PERSONALITY</a><span class="enum-member-value"><tt class="highlighted"><span class="num">9</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_REGISTER_PERSONALITY</tt> (from Linux 5.6)</p><p>If an application wants to use a ring with different kinds of credentials, it can register
them upfront. We don't lookup credentials, the credentials of the task calling
IORING_REGISTER_PERSONALITY is used.</p><p>An 'id' is returned for the application to use in subsequent personality support.</p></div></td></tr><tr class="enum-member" id="UNREGISTER_PERSONALITY"><td><a class="enum-member-name" href="#UNREGISTER_PERSONALITY">UNREGISTER_PERSONALITY</a><span class="enum-member-value"><tt class="highlighted"><span class="num">10</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IORING_UNREGISTER_PERSONALITY</tt> (from Linux 5.6)</p></div></td></tr></table><div><h2 id="meta"><a class="header-anchor" href="#meta">Meta</a></h2><div class="documentation-comment source-section other-section"><h3 id="source"><a class="header-anchor" href="#source">Source</a></h3><div><p><a href="source/during.io_uring.d.html#L840">See Implementation</a><br /></p></div></div></div></div>
		<div id="page-nav"><a class="parent" href="during.html">during</a><a class="parent" href="during.io_uring.html">io_uring</a>
		<span class="type-separator">enums</span><ul><li><a class="enum" href="during.io_uring.AcceptFlags.html">AcceptFlags</a></li><li><a class="enum" href="during.io_uring.CQEFlags.html">CQEFlags</a></li><li><a class="enum" href="during.io_uring.CQRingFlags.html">CQRingFlags</a></li><li><a class="enum" href="during.io_uring.EnterFlags.html">EnterFlags</a></li><li><a class="enum" href="during.io_uring.MsgFlags.html">MsgFlags</a></li><li><a class="enum" href="during.io_uring.Operation.html">Operation</a></li><li><a class="enum" href="during.io_uring.PollEvents.html">PollEvents</a></li><li><a class="enum current" href="during.io_uring.RegisterOpCode.html">RegisterOpCode</a></li><li><a class="enum" href="during.io_uring.SetupFeatures.html">SetupFeatures</a></li><li><a class="enum" href="during.io_uring.SetupFlags.html">SetupFlags</a></li><li><a class="enum" href="during.io_uring.SubmissionEntryFlags.html">SubmissionEntryFlags</a></li><li><a class="enum" href="during.io_uring.SyncFileRangeFlags.html">SyncFileRangeFlags</a></li><li><a class="enum" href="during.io_uring.TimeoutFlags.html">TimeoutFlags</a></li></ul><span class="type-separator">functions</span><ul><li><a class="function" href="during.io_uring.io_uring_enter.html">io_uring_enter</a></li><li><a class="function" href="during.io_uring.io_uring_register.html">io_uring_register</a></li><li><a class="function" href="during.io_uring.io_uring_setup.html">io_uring_setup</a></li></ul><span class="type-separator">manifest constants</span><ul><li><a class="manifest-constant" href="during.io_uring.IO_URING_OP_SUPPORTED.html">IO_URING_OP_SUPPORTED</a></li><li><a class="manifest-constant" href="during.io_uring.SPLICE_F_FD_IN_FIXED.html">SPLICE_F_FD_IN_FIXED</a></li></ul><span class="type-separator">structs</span><ul><li><a class="struct" href="during.io_uring.CompletionEntry.html">CompletionEntry</a></li><li><a class="struct" href="during.io_uring.CompletionQueueRingOffsets.html">CompletionQueueRingOffsets</a></li><li><a class="struct" href="during.io_uring.KernelTimespec.html">KernelTimespec</a></li><li><a class="struct" href="during.io_uring.SetupParameters.html">SetupParameters</a></li><li><a class="struct" href="during.io_uring.SubmissionEntry.html">SubmissionEntry</a></li><li><a class="struct" href="during.io_uring.SubmissionQueueRingOffsets.html">SubmissionQueueRingOffsets</a></li></ul></div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>
</body>
</html>