<!DOCTYPE html>
<html>
<head>
        <title>RegisterOpCode (during.io_uring.RegisterOpCode)</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		</nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		<h1>RegisterOpCode</h1><div class="breadcrumbs"><a class="breadcrumb" href="during.html">during</a><a class="breadcrumb" href="during.io_uring.html">io_uring</a></div><div><div class="documentation-comment synopsis"><div><p>io_uring_register(2) opcodes and arguments</p></div></div></div><div class="annotated-prototype"></div><h2 id="values"><a class="header-anchor" href="#values">Values</a></h2><table class="enum-members"><tr><th>Value</th><th>Meaning</th></tr><tr class="enum-member" id="REGISTER_BUFFERS"><td><a class="enum-member-name" href="#REGISTER_BUFFERS">REGISTER_BUFFERS</a><span class="enum-member-value"><tt class="highlighted"><span class="num">0</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">arg</tt> points to a struct iovec array of nr_args entries.  The buffers associated with the
iovecs will be locked in memory and charged against the user's RLIMIT_MEMLOCK resource limit.
See getrlimit(2) for more  informa&#8208; tion.   Additionally,  there  is a size limit of 1GiB per
buffer.  Currently, the buffers must be anonymous, non-file-backed memory, such as that
returned by malloc(3) or mmap(2) with the MAP_ANONYMOUS flag set.  It is expected that this
limitation will be lifted in the future. Huge pages are supported as well. Note that the
entire huge page will be pinned in the kernel, even if only a portion of it is used.</p><p>After a successful call, the supplied buffers are mapped into the kernel and eligible for
I/O.  To make use of them, the application must specify the IORING_OP_READ_FIXED or
IORING_OP_WRITE_FIXED opcodes in the submis&#8208; sion  queue  entry (see the struct io_uring_sqe
definition in io_uring_enter(2)), and set the buf_index field to the desired buffer index.
The memory range described by the submission queue entry's addr and len fields must fall
within the indexed buffer.</p><p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as
long as the range is within the originally mapped region.</p><p>An application can increase or decrease the size or number of registered buffers by first
unregistering the existing buffers, and then issuing a new call to io_uring_register() with
the new buffers.</p><p>An application need not unregister buffers explicitly before shutting down the io_uring
instance.</p></div></td></tr><tr class="enum-member" id="UNREGISTER_BUFFERS"><td><a class="enum-member-name" href="#UNREGISTER_BUFFERS">UNREGISTER_BUFFERS</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1</span></tt></span><div class="enum-attributes"></div></td><td><div><p>This operation takes no argument, and <tt class="inline-code">arg</tt> must be passed as NULL. All previously registered
buffers associated with the io_uring instance will be released.</p></div></td></tr><tr class="enum-member" id="REGISTER_FILES"><td><a class="enum-member-name" href="#REGISTER_FILES">REGISTER_FILES</a><span class="enum-member-value"><tt class="highlighted"><span class="num">2</span></tt></span><div class="enum-attributes"></div></td><td><div><p>Register files for I/O. <tt class="inline-code">arg</tt> contains a pointer to an array of <tt class="inline-code">nr_args</tt> file descriptors
(signed 32 bit integers).</p><p>To make use of the registered files, the IOSQE_FIXED_FILE flag must be set in the flags
member of the struct io_uring_sqe, and the fd member is set to the index of the file in the
file descriptor array.</p><p>Files are automatically unregistered when the io_uring instance is torn down. An application
need only unregister if it wishes to register a new set of fds.</p></div></td></tr><tr class="enum-member" id="UNREGISTER_FILES"><td><a class="enum-member-name" href="#UNREGISTER_FILES">UNREGISTER_FILES</a><span class="enum-member-value"><tt class="highlighted"><span class="num">3</span></tt></span><div class="enum-attributes"></div></td><td><div><p>This operation requires no argument, and <tt class="inline-code">arg</tt> must be passed as NULL.  All previously
registered files associated with the io_uring instance will be unregistered.</p></div></td></tr><tr class="enum-member" id="REGISTER_EVENTFD"><td><a class="enum-member-name" href="#REGISTER_EVENTFD">REGISTER_EVENTFD</a><span class="enum-member-value"><tt class="highlighted"><span class="num">4</span></tt></span><div class="enum-attributes"></div></td><td><div></div></td></tr><tr class="enum-member" id="UNREGISTER_EVENTFD"><td><a class="enum-member-name" href="#UNREGISTER_EVENTFD">UNREGISTER_EVENTFD</a><span class="enum-member-value"><tt class="highlighted"><span class="num">5</span></tt></span><div class="enum-attributes"></div></td><td><div></div></td></tr><tr class="enum-member" id="REGISTER_FILES_UPDATE"><td><a class="enum-member-name" href="#REGISTER_FILES_UPDATE">REGISTER_FILES_UPDATE</a><span class="enum-member-value"><tt class="highlighted"><span class="num">6</span></tt></span><div class="enum-attributes"></div></td><td><div></div></td></tr></table><div><h2 id="meta"><a class="header-anchor" href="#meta">Meta</a></h2><div class="documentation-comment source-section other-section"><h3 id="source"><a class="header-anchor" href="#source">Source</a></h3><div><p><a href="source/during.io_uring.d.html#L432">See Implementation</a><br /></p></div></div></div></div>
		<div id="page-nav"><a class="parent" href="during.html">during</a><a class="parent" href="during.io_uring.html">io_uring</a>
		<span class="type-separator">enums</span><ul><li><a class="enum" href="during.io_uring.EnterFlags.html">EnterFlags</a></li><li><a class="enum" href="during.io_uring.Operation.html">Operation</a></li><li><a class="enum" href="during.io_uring.PollEvents.html">PollEvents</a></li><li><a class="enum current" href="during.io_uring.RegisterOpCode.html">RegisterOpCode</a></li><li><a class="enum" href="during.io_uring.SetupFeatures.html">SetupFeatures</a></li><li><a class="enum" href="during.io_uring.SetupFlags.html">SetupFlags</a></li><li><a class="enum" href="during.io_uring.SubmissionEntryFlags.html">SubmissionEntryFlags</a></li><li><a class="enum" href="during.io_uring.TimeoutFlags.html">TimeoutFlags</a></li></ul><span class="type-separator">functions</span><ul><li><a class="function" href="during.io_uring.io_uring_enter.html">io_uring_enter</a></li><li><a class="function" href="during.io_uring.io_uring_register.html">io_uring_register</a></li><li><a class="function" href="during.io_uring.io_uring_setup.html">io_uring_setup</a></li></ul><span class="type-separator">structs</span><ul><li><a class="struct" href="during.io_uring.CompletionEntry.html">CompletionEntry</a></li><li><a class="struct" href="during.io_uring.CompletionQueueRingOffsets.html">CompletionQueueRingOffsets</a></li><li><a class="struct" href="during.io_uring.SetupParameters.html">SetupParameters</a></li><li><a class="struct" href="during.io_uring.SubmissionEntry.html">SubmissionEntry</a></li><li><a class="struct" href="during.io_uring.SubmissionQueueRingOffsets.html">SubmissionQueueRingOffsets</a></li></ul></div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>
</body>
</html>